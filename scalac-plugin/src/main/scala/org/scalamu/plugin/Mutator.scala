package org.scalamu.plugin

import com.typesafe.scalalogging.Logger
import org.scalamu.common.MutantId
import org.scalamu.plugin.util.{CompilerAccess, GlobalExtractors, TreeEnrichment, TreeSanitizer}

import scala.tools.nsc.Global

/**
 * Base trait for all mutations.
 */
trait Mutator {
  def mutatingTransformer(
    global: Global,
    config: ScalamuScalacConfig
  ): MutatingTransformer

  def description: String
}

abstract class MutatingTransformer(
  private val config: ScalamuScalacConfig
)(
  override implicit val global: Global
) extends CompilerAccess
    with GlobalExtractors
    with TreeSanitizer
    with TreeEnrichment {

  override def isMutationGuard(symbolName: String): Boolean =
    config.guard.isGuardSymbol(symbolName)

  trait Transformer extends global.Transformer {
    import global._

    private val fullName: Symbol => String = _.fullNameString

    private val excludedSymbols: Seq[String] = Seq(
      "scala.reflect.api.Exprs.Expr",
      "scala.reflect.api.Trees.Tree",
      "scala.reflect.macros.Universe.Tree"
    )

    private[this] var currentPackage: String   = _
    private[this] var currentClassName: String = _

    private final def tryUpdatePackageAndClass(tree: Tree): (String, String) = {
      tree match {
        case t: DefTree =>
          Option(t.symbol) match {
            case Some(sym) =>
              currentPackage   = sym.enclosingPackage.fullName
              currentClassName = sym.enclosingTopLevelClass.fullName
            case None =>
          }
        case _ =>
      }
      currentPackage -> currentClassName
    }

    override final def transform(tree: Tree): Tree = tree match {
      case t if t.attachments.all.toString.contains("MacroExpansionAttachment")                => tree
      case t if Option(t.symbol).exists(s => !config.ignoreSymbols.accepts(fullName(s)))       => tree
      case DefDef(mods, _, _, _, _, _) if mods.isSynthetic || mods.isMacro                     => tree
      case cdef: ClassDef if !config.targetClasses.accepts(tryUpdatePackageAndClass(cdef)._2)  => tree
      case mdef: ModuleDef if !config.targetClasses.accepts(tryUpdatePackageAndClass(mdef)._2) => tree
      case macroImpl: DefDef if Option(macroImpl.tpt.symbol).exists(fullName andThen excludedSymbols.contains) =>
        tree
      case ClassDef(_, _, _, Template(parents, _, _))
          if parents.map(_.tpe.typeSymbol.fullName).contains("scala.reflect.api.TypeCreator") =>
        tree
      case t @ GuardedMutant(guard, mutated, alternative) =>
        // do not mutate code generated by another mutation
        treeCopy.If(t, guard, mutated, transform(alternative))
      case _ =>
        tryUpdatePackageAndClass(tree)
        (mutate andThen retype).applyOrElse(tree, continue)
    }

    protected final def generateMutantReport(tree: Tree, mutated: Tree): MutantId = {
      val oldTree = showCode(TreePrettifier(tree))
      val mutatedTree = showCode(TreePrettifier(mutated))
      
      val info = MutantInfo(
        mutator,
        currentRunId,
        currentPackage,
        tree.pos,
        oldTree,
        mutatedTree
      )
      if (!tree.pos.isDefined) {
        Transformer.log.info(s"Mutant $info in tree $tree has undefined position.")
      }
      config.reporter.report(info)
      info.id
    }

    private val continue: PartialFunction[Tree, Tree] = PartialFunction(super.transform)

    protected final val retype: PartialFunction[Tree, Tree] = PartialFunction(typer.typed)

    protected def mutate: PartialFunction[Tree, Tree]

    private def sanitizeTree(tree: Tree): Tree =
      if (config.sanitizeTrees) NestedMutantRemover(tree) else tree

    protected final def guard(mutated: Tree, alternative: Tree, id: MutantId): Tree =
      config.guard(global)(sanitizeTree(mutated), alternative, id)
  }

  object Transformer {
    private val log = Logger[Transformer]
  }

  protected def mutator: Mutator

  protected def transformer: Transformer

  def apply(tree: global.Tree): global.Tree = transformer.transform(tree)
}
