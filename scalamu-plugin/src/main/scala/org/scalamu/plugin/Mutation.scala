package org.scalamu.plugin

import org.scalamu.plugin.mutations.GlobalUtils

trait Mutation {
  def mutatingTransformer(ctx: MutationContext): MutatingTransformer
}

abstract class MutatingTransformer(val context: MutationContext) extends GlobalUtils(context.global) {
  trait Transformer extends global.Transformer {
    import global._
    import typer.typed

    override final def transform(tree: Tree): Tree = tree match {
      case DefDef(mods, _, _, _, _, _) if mods.isSynthetic => tree
      case ClassDef(_, _, _, Template(parents, _, _))
          if parents.map(_.tpe.typeSymbol.fullName).contains("scala.reflect.api.TypeCreator") =>
        tree
      case GuardedMutation(guard, mutated, alternative) =>
        // do not mutate code generated by another mutationQ
        q"if ($guard) $mutated else ${transform(alternative)}"
      case _ =>
        val mutated = mutate.applyOrElse(tree, continue)
        if (mutated != tree) {
          typed(mutated)
        } else mutated
    }

    protected final def reportMutation(tree: Tree, mutated: Tree): Unit = {
      val info = MutationInfo(
        mutation,
        currentRunId,
        tree.pos,
        show(tree),
        show(mutated)
      )
      context.mutationReporter.report(info)
    }

    protected final def continue: PartialFunction[Tree, Tree] = PartialFunction(super.transform)

    protected def mutate: PartialFunction[Tree, Tree]
  }

  protected final def mutationGuard(mutated: global.Tree, untouched: global.Tree): global.Tree = {
    import global._
    q"if (true) $mutated else $untouched"
  }

  protected def mutation: Mutation

  protected def transformer: Transformer

  def apply(tree: global.Tree): global.Tree = transformer.transform(tree)
}
